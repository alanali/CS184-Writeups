<html>
	<head>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<h1>Project 2: MeshEdit</h1>
		<h3>By Alana Li</h3>

		<h2>Overview</h2>
		<p>In this project I implemented Bezier curves and surfaces using de Casteljau subdivision. I also implemented smoothing of meshes with averaged normals, as well as loop subdivision for upsampling meshes.
		</p>
		<p>TODO
		</p>

		<h2>Part 1: Bezier Curves with 1D de Casteljau Subdivision</h2>
		<div class="row">
		  <div class="column">
		    <img src="Images/lerp0.png" style="width:100%; padding: 0%">
				<p>Step 0</p>
		  </div>
		  <div class="column">
		    <img src="Images/lerp1.png" style="width:100%; padding: 0%">
				<p>Step 1</p>
		  </div>
		  <div class="column">
		    <img src="Images/lerp2.png" style="width:100%; padding: 0%">
				<p>Step 2</p>
		  </div>
		</div>
		<br>
		<div class="row">
		  <div class="column">
		    <img src="Images/lerp3.png" style="width:100%; padding: 0%">
				<p>Step 3</p>
		  </div>
		  <div class="column">
		    <img src="Images/lerp4.png" style="width:100%; padding: 0%">
				<p>Step 4</p>
		  </div>
		  <div class="column">
		    <img src="Images/lerp5.png" style="width:100%; padding: 0%">
				<p>Step 5</p>
		  </div>
		</div>
		<br>
		<div class="row">
		  <div class="column">
		    <img src="Images/lerp6.png" style="width:100%; padding: 0%">
				<p>Step 6</p>
		  </div>
		  <div class="column">
		    <img src="Images/lerp7.png" style="width:100%; padding: 0%">
				<p>Final Curve</p>
		  </div>
		  <div class="column">
		    <img src="Images/lerp8.png" style="width:100%; padding: 0%">
				<p>Modified t</p>
		  </div>
		</div>
		<p>Given a Bezier curve with n control points, we can apply de Casteljau's algoritm to repeatedly compute linear interpolations between the points to end up with a smooth curve. We do this by adding lines between neighboring pairs of lines between control points at position t. We then repeat the process with the calculated new lines until we end up with just one point, which becomes a point on the Bezier curve.</p>
		<p>To do this, I used a for loop to call lerp on every pair of adjacent control points. Each new calculated point is added to the vector array and the process continues until there is only one point left.</p>
		<div class="row">
		  <div class="column">
		    <img src="Images/lerp9.png" style="width:100%; padding: 0%">
				<p>Different Control Points</p>
		  </div>
		</div>

		<h2>Part 2: Bezier Surfaces with Serarable 1D de Casteljau</h2>
		<div class="row">
		  <div class="column">
		    <img src="Images/teapot.png" style="width:100%; padding: 0%">
				<p>Mesh Teapot</p>
		  </div>
		</div>
		<p>Bezier surfaces can be represented as a series of Bezier curves lined up. We can use de Casteljau's algorithm to calculate the control point of each curve in one dimension with our u variable, before linearly interpolating in the other direction with the input v.</p>
		<p>This is done by evaluating the control points one row at a time in the u dimension. This determines the Bezier curves. We then evaluate the u points at t in the v direction, creating the final Bezier surface.</p>

		<h2>Part 3: Area-Weighted Vertex Normals</h2>
		<div class="row">
		  <div class="column">
		    <img src="Images/notsmooth.png" style="width:100%; padding: 0%">
				<p1>Flat Shading</p1>
		  </div>
		  <div class="column">
		    <img src="Images/smooth.png" style="width:100%; padding: 0%">
				<p1>Phong Shading</p1>
		  </div>
		</div>
		<p>I used a HalfedgeCIter object to keep track of the starting halfedge, looping until we eventually come back to the start. Halfedge objects have a pointer to a trianglar face with 3 vertices. By following the halfedge's next() and position pointers we can get the positions of all 3 vertices of the face. I then took the cross product of the difference between adjacent vectors and added that to the sum. I then move on to the next surface by accessing the halfedge's twin() then next() pointer. When the loop is finished, the normalized vector of the sum is returned.</p>

		<h2>Part 4: Edge Flip</h2>
		<div class="row">
		  <div class="column">
		    <img src="Images/flipsoff.png" style="width:100%; padding: 0%">
				<p1>Before Flipping</p1>
		  </div>
		  <div class="column">
		    <img src="Images/flips.png" style="width:100%; padding: 0%">
				<p1>After Flipping</p1>
		  </div>
		</div>
		<p>To implement this feature I labeled all the vertices and edges before and after an edge flip, as well as noted the changes in face. It was very helpful to draw a diagram and label everything before and after a flip. I assigned all the initial vertices, faces, halfedges, and edges to variables. Then I reassigned the pointers using setNeighbors to change them to the vertices, halfedges, edges, and faces after the flip.</p>
		<p>I ran into some bugs that involved holes in my mesh, but I solved it by updating the faces after flipping.</p>

		<h2>Part 5: Edge Split</h2>
		<div class="row">
			<div class="column">
				<img src="Images/normal.png" style="width:100%; padding: 0%">
				<p1>No Splitting</p1>
			</div>
			<div class="column">
				<img src="Images/splits.png" style="width:100%; padding: 0%">
				<p1>Splits</p1>
			</div>
			<div class="column">
				<img src="Images/splitsflips.png" style="width:100%; padding: 0%">
				<p1>Splits and Flips</p1>
			</div>
		</div>
		<p>Once again I labeled the different verticies and edges before any splitting, then reassigned them after the split. This involved adding a vertex, 2 faces, 3 edges, and 6 halfedges to the mesh.</p>

		<h2>Part 6: Loop Subdivision for Mesh Upsampling</h2>
		
		<p>TODO</p>
		<p>TODO</p>
	</body>
</html>
